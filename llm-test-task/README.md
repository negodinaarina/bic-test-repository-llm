## Инструкция по запуску

## Что и как реализовано:
Общая структура проекта наглядно показана ниже (и там же краткое описание назначение каждого файла)
### Структура и компоненты:

```text
├── app
│   ├── Dockerfile
│   ├── .env
│   ├── example.env
│   └── src
│       ├── api
│       │   ├── endpoints.py
│       │   └── __init__.py
│       ├── config.py
│       ├── logger.py
│       ├── main.py
│       ├── schemas
│       │   ├── __init__.py
│       │   ├── models.py
│       │   └── prompts.py
│       └── services
│           ├── base
│           │   ├── client.py
│           │   ├── exceptions.py
│           │   └── __init__.py
│           └── openrouter
│               ├── client.py
│               └── __init__.py
├── benchmarks
├── docker-compose.yml
├── .gitignore
├── logs
│   └── server_logs.txt
├── Makefile
├── pyproject.toml
├── README.md

```

- **app/** – основная директория приложения:
  - **src/** – исходный код:
    - **api/** – роуты и эндпоинты FastAPI:
      - `endpoints.py` – обработчики HTTP-запросов.
    - `config.py` – конфигурация приложения (константы и параметры).
    - `logger.py` – глобальный логгер и middleware для логгирования запросов и ошибок.
    - `main.py` – точка входа FastAPI.
    - **schemas/** – Pydantic-схемы для  валидации данных:
      - `models.py` – схемы моделей.
      - `prompts.py` – схемы для работы с промптами.
    - **services/** – сервисный слой:
      - **base/** – базовый клиент для работы с внешними API и общие исключения.
      - **openrouter/** – клиент для работы с OpenRouter API.
  - `Dockerfile` – контейнеризация приложения.
  - `.env / example.env` – файлы с переменными окружения.

- **benchmarks/** – директория для хранения полученных benchmarks.
- **logs/** – директория с логами (`server_logs.txt`).
- `docker-compose.yml` – для запуска приложения через Docker Compose.
- `Makefile` – автоматизация команд для разработки и запуска.

### Как решались задачи:

#### Уровень 1 (Минимально рабочее решение)

Основная часть данной задачи заключалась в реализации механизма выполнения запросов к OpenRouter и обработки получаемых ответов. По сути, здесь мы выступаем в роли прокси, получая запрос от пользователя в эндпоинтах, преобразовывая их в формату, поддерживаемому OpenRouter, получаем ответ, приводим к более простому виду (отбрасываем бОльшую часть полей ответа) и возвращаем пользователю.

Для выполнения http-запросов был написан базовый клиент, в котором описана основная логика отправки get и post зарпросов (при необходимости, класс можно легко расширить для put, patch, delete и других методов http).
От данного класса наследуется клиент для работы с OpenRouter (или другим API, который поддерживает такой формат запросов), и в данном классе уже реализованы методы отправки запросов на конкретные ручки OpenRouter для получения моделей и генерации ответов моделей на промты пользователя.

*Что хорошо: базовый url сервиса хранится в конфигурации приложения `config.py`, и если понадобится его сменить, то это можно сделать в одном месте. Ключ доступа к OpenRoute API хранится в переменных окружения, устанавливается в заголовки запросов при инициализации клиента один раз и отправляется со всеми запросами.*

Несмотря на то, что доступные модели обновяются не часто, они все равно обновляются, из-за чего мы не можем получить их один раз и использовать полученные модели без обновления. При этом не хочется постоянно ходить в OpenRoute, так как это долго, и здесь напрашивается кеширование. Поднимать redis избыточно, писать свой механизм также не имеет смысла, для этого используется asyncache. Настройки кешмрования также можно изменить в `config.py`
Результат кеширования есть в логах (первый запрос - действительный запрос к OpenRouter, второй - получение моделей из кеша):
```
2025-09-11 01:15:44,462 - INFO - OK | GET /models | handler=get_models_names | time=0.5164s | status_code=200
2025-09-11 01:15:45,953 - INFO - OK | GET /models | handler=get_models_names | time=0.0019s | status_code=200
```

Логгирование и обработка ошибок вынесена в middleware, чтобы не засорять логику работы ручек вызовом логера для записи ошибок и блоками try/except. Настроить директорию для хранения логов можно произвести также в `config.py`. По умолчанию это директория на уровне основной директории приложения (также чтобы не засорять директорию приложения файлами к нему не относящимися).
Работу `logger.py/LoggingMiddleware` можно кратко описать так:
- Для успешных ответов пишет info с методом, URL, обработчиком, временем и кодом ответа.
- Для ошибок (HTTPException или любых других) пишет error с методом, URL, обработчиком, временем, кодом ответа и трассировкой и возвращает в ответе пользователю JSON с деталями ошибки.
- Для ошибок со стороны OpenRouter написан кастомный класс ClientError, при обработке данной ошибки в лог пишется только метод, URL, обработчик, время и код ответа (Трассировка не нужна, так как ошибка не на нашей стороне).

#### Уровень 2 (Продвинутая реализация)

В данном задании изменяются запросы от пользователя на ручку `/generate`, для обновления было достаточно подправить схемы в schemas.py/prompts и добавить новые поля в логике обработчика. 

Также необходимо было реализовать глобальный обработчик ошибок от внешнего API со статусом 429. Так как был написан базовый клиент для работы с внешними API, для реализации логики экспоненциальных ретраев достаточно было просто добавить его на метод _make_request, для этого использовалось готовое решение из tenacity(но при желании или необходимости реализовать кастомную логику ретраев, не доступную в существующих решениях, можно просто написать свой декоратор).
Все настройки ретраев(количество, коэффициент расчета времени, минимальное и максимальное значение задержки) также вынесены в `config.py`.