## Инструкция по запуску

1) Переходим в директорию `/bic-test-repository-llm/llm-test-task/app`
2) Собираем образ: `docker build -t fastapi-app .`
3) Запускаем контейнер `docker run -p 8000:8000 fastapi-app`
4) Приложение доступно по `0.0.0.0:8000`, сваггер по `0.0.0.0:8000/docs`

## Что и как реализовано:
Общая структура проекта наглядно показана ниже (и там же краткое описание назначение каждого файла)
### Структура и компоненты:

```text
├── app
│   ├── Dockerfile
│   ├── .env
│   ├── example.env
│   └── src
│       ├── api
│       │   ├── endpoints.py
│       │   └── __init__.py
│       ├── config.py
│       ├── logger.py
│       ├── main.py
│       ├── schemas
│       │   ├── benchmarks.py
│       │   ├── __init__.py
│       │   ├── models.py
│       │   └── prompts.py
│       └── services
│           ├── base
│           │   ├── client.py
│           │   ├── exceptions.py
│           │   └── __init__.py
│           ├── benchmarker
│           │   ├── file_utils.py
│           │   ├── __init__.py
│           │   └── run_utils.py
│           └── openrouter
│               ├── client.py
│               └── __init__.py
├── benchmarks
├── .gitignore
├── logs
│   └── server_logs.txt
├── Makefile
├── .mypy_cache
├── promts
├── pyproject.toml
├── README.md
└── uv.lock

```

- **app/** – основная директория приложения:
  - **src/** – исходный код:
    - **api/** – роуты и эндпоинты FastAPI:
      - `endpoints.py` – обработчики HTTP-запросов.
    - `config.py` – конфигурация приложения (константы и параметры).
    - `logger.py` – глобальный логгер и middleware для логгирования запросов и ошибок.
    - `main.py` – точка входа FastAPI.
    - **schemas/** – Pydantic-схемы для  валидации данных:
      - `models.py` – схемы моделей.
      - `prompts.py` – схемы для работы с промптами.
      - `behcnmarks.py` - схемы для работы с бенчмарками
    - **services/** – сервисный слой:
      - **base/** – базовый клиент для работы с внешними API и общие исключения.
      - **openrouter/** – клиент для работы с OpenRouter API.
      - **benchmarker/** - утилиты для запуска и записи бенчмарков.
  - `Dockerfile` – контейнеризация приложения.
  - `.env / example.env` – файлы с переменными окружения.

- **benchmarks/** – директория для хранения полученных benchmarks.
- **prompts/** - директорий с примерами результатов генерации 
- **logs/** – директория с логами (`server_logs.txt`).
- `docker-compose.yml` – для запуска приложения через Docker Compose.
- `Makefile` – автоматизация команд для разработки и запуска.

### Как решались задачи:

#### Уровень 1 (Минимально рабочее решение)

Основная часть данной задачи заключалась в реализации механизма выполнения запросов к OpenRouter и обработки получаемых ответов. По сути, здесь мы выступаем в роли прокси, получая запрос от пользователя в эндпоинтах, преобразовывая их в формату, поддерживаемому OpenRouter, получаем ответ, приводим к более простому виду (отбрасываем бОльшую часть полей ответа) и возвращаем пользователю.

Для выполнения http-запросов был написан базовый клиент, в котором описана основная логика отправки get и post зарпросов (при необходимости, класс можно легко расширить для put, patch, delete и других методов http).
От данного класса наследуется клиент для работы с OpenRouter (или другим API, который поддерживает такой формат запросов), и в данном классе уже реализованы методы отправки запросов на конкретные ручки OpenRouter для получения моделей и генерации ответов моделей на промты пользователя.

*Что хорошо: базовый url сервиса хранится в конфигурации приложения `config.py`, и если понадобится его сменить, то это можно сделать в одном месте. Ключ доступа к OpenRoute API хранится в переменных окружения, устанавливается в заголовки запросов при инициализации клиента один раз и отправляется со всеми запросами.*

Несмотря на то, что доступные модели обновяются не часто, они все равно обновляются, из-за чего мы не можем получить их один раз и использовать полученные модели без обновления. При этом не хочется постоянно ходить в OpenRoute, так как это долго, и здесь напрашивается кеширование. Поднимать redis избыточно, писать свой механизм также не имеет смысла, для этого используется asyncache. Настройки кешмрования также можно изменить в `config.py`
Результат кеширования есть в логах (первый запрос - действительный запрос к OpenRouter, второй - получение моделей из кеша):
```
2025-09-11 01:15:44,462 - INFO - OK | GET /models | handler=get_models_names | time=0.5164s | status_code=200
2025-09-11 01:15:45,953 - INFO - OK | GET /models | handler=get_models_names | time=0.0019s | status_code=200
```
Примеры запросов и ответов на `/generate` можно посмотреть в `/promts`, например: 

```
{
  "request": {
    "model": "deepseek/deepseek-chat-v3.1:free",
    "prompt": "почему небо голубое"
  },
  "response": {
    "text": "?». Вопрос, который задают многие дети, но на который не так-то просто ответить. Конечно, можно сказать, что небо голубое из-за того, как солнечный свет взаимодействует с атмосферой Земли. Но как именно? Почему небо голубое, а не фиолетовое? Или зеленый? Или черный, как в космосе? Вот как это работает.\n\n### Почему небо голубое?\n\nКороткий ответ: Солнце посылает во всех направлениях свет всех возможных цветов. Поскольку синий свет имеет более короткую длину волны, он рассеивается больше, чем другие цвета, поэтому небо выглядит голубым. Но давайте углубимся в детали.\n\nВо-первых, мы должны отметить, что Солнце излучает белый свет. Белый свет — это не цвет сам по себе, а комбинация всех цветов видимого спектра: красного, оранжевого, желтого, зеленого, синего и фиолетового.\n\nКаждый из этих цветов имеет разную длину волны. Красный свет имеет самую длинную длину волны, а фиолетовый — самую короткую. Когда солнечный свет проходит через атмосферу, он сталкивается с молекулами и частицами. Эти столкновения заставляют свет рассеиваться. Рассеяние относится к тому, как свет поглощается и повторно излучается в разных направлениях. Однако не все цвета рассеиваются одинаково. Более короткие длины волн (синий и фиолетовый) рассеиваются гораздо больше, чем более длинные (красный, оранжевый, желтый). Это известно как рассеяние Рэлея, названное в честь лорда Рэлея, который впервые описал его.\n\nИтак, синий свет рассеивается во всех направлениях, заставляя небо казаться голубым со всех сторон. Между тем, другие цвета не рассеиваются так сильно, поэтому мы видим небо преимущественно синим.\n\n### Почему небо не фиолетовое?\n\nЕсли фиолетовый свет имеет еще более короткую длину волны, чем синий, то почему небо не кажется фиолетов",
    "tokens_used": 520,
    "latency_seconds": 35.73705989299924
  }
}
```

Логгирование и обработка ошибок вынесена в middleware, чтобы не засорять логику работы ручек вызовом логера для записи ошибок и блоками try/except. Настроить директорию для хранения логов можно произвести также в `config.py`. По умолчанию это директория на уровне основной директории приложения (также чтобы не засорять директорию приложения файлами к нему не относящимися).
Работу `logger.py/LoggingMiddleware` можно кратко описать так:
- Для успешных ответов пишет info с методом, URL, обработчиком, временем и кодом ответа.
- Для ошибок (HTTPException или любых других) пишет error с методом, URL, обработчиком, временем, кодом ответа и трассировкой и возвращает в ответе пользователю JSON с деталями ошибки.
- Для ошибок со стороны OpenRouter написан кастомный класс ClientError, при обработке данной ошибки в лог пишется только метод, URL, обработчик, время и код ответа (Трассировка не нужна, так как ошибка не на нашей стороне).

#### Уровень 2 (Продвинутая реализация)

В данном задании изменяются запросы от пользователя на ручку `/generate`, для обновления было достаточно подправить схемы в schemas.py/prompts и добавить новые поля в логике обработчика. 

Также необходимо было реализовать глобальный обработчик ошибок от внешнего API со статусом 429. Так как был написан базовый клиент для работы с внешними API, для реализации логики экспоненциальных ретраев достаточно было просто добавить его на метод _make_request, для этого использовалось готовое решение из `tenacity`(но при желании или необходимости реализовать кастомную логику ретраев, не доступную в существующих решениях, можно просто написать свой декоратор).
Все настройки ретраев(количество, коэффициент расчета времени, минимальное и максимальное значение задержки) также вынесены в `config.py`.

Далее необходимо было реализовать эндпоинт `/benchmark`, на вход он принимает prompt_file, model, runs, concurrency. Основная логика выполнения тестов вынесена в `services/benchmark/run_utils.py`.
Две функции в донном файле позволяют выполнять промпты асинхронно (если передать concurrency >= 2), при этом количество парралельных исполнений как раз ограничевается числом concurrency с помощью семафора(есть вероятность улететь в бан со стороны OpenRouter, так как на каждого пользователя установлено ограничение по запросам в минуту). Каждый запуск генерации при этом фиксируется в лог, а также фиксируются возникающие ошибки (но при этом при возникновении выполнение не приостанавливается).
Пример логов benchmark:
```
2025-09-12 00:49:38,151 - INFO - STARTED SINGLE PROMPT IN BENCHMARK MODEL: tngtech/deepseek-r1t-chimera:free, RUN: 1
2025-09-12 00:49:45,337 - INFO - STARTED SINGLE PROMPT IN BENCHMARK MODEL: tngtech/deepseek-r1t-chimera:free, RUN: 1
2025-09-12 00:49:53,718 - INFO - STARTED SINGLE PROMPT IN BENCHMARK MODEL: tngtech/deepseek-r1t-chimera:free, RUN: 1
2025-09-12 00:50:02,320 - INFO - STARTED SINGLE PROMPT IN BENCHMARK MODEL: tngtech/deepseek-r1t-chimera:free, RUN: 1
2025-09-12 00:50:11,153 - INFO - STARTED SINGLE PROMPT IN BENCHMARK MODEL: tngtech/deepseek-r1t-chimera:free, RUN: 1
2025-09-12 00:50:25,180 - INFO - OK | POST /benchmark | handler=benchmark | time=47.0304s | status_code=200
```

Статистика складывается в директории `/benchmark`, для каждого запуска генерируется новый файл со временем исполнения и моделью в названии. 